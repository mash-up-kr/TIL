## JPA 지연 로딩

JPA를 사용하면 체이닝으로 객체 그래프 탐색이 쉽다. ( 객체 그래프는 노드가 객체인 그래프다. )

JPA는 연관 객체를 사용하는 그 순간에 SELECT SQL을 실행한다.  
실제 객체를 이용할 때 까지 DB 조회를 미뤄 **지연 로딩(Lazy Loading)**이라 한다.

연관 객체를 사용해야 하는 빈도가 많다면, 한 테이블 씩 SELECT SQL로 불러오는건 비효율적일 수도 있다.  
JPA 에서 연관 객체를 함께 불러올 지, 사용할 때 불러올 지 설정으로 정의할 수 있다.

## 객체 비교

JPA로 불러온 객체는 동일성 비교 기능이 추가된다.

데이터베이스의 테이블 안에서는 키가 같은지로 동일한 지 판단한다.  
그러나 자바의 객체는 비교 연산자(== 연산자)로는 같은 메모리를 참조하고 있는지 검사한다.

데이터를 불러올 때 JDBC API로 새로운 객체를 반환했다면, 키가 같아도 동일성 비교연산자 결과는 객체 자체의 주소가 달라 `false`로 나타날 것이다.  
이를 해결하기 위해서는 Equals() 메소드를 오버라이딩하여 사용했을 것이다.  
그러나 여전히 `==` 연산자를 사용할 수 없어 패러다임 불일치가 일어난다.  

JPA는 `==` 연산자를 사용해 비교할 수 있다.

```java
String userId = "51";
User user1 = jpa.find(User.class, userId);
User user2 = jpa.find(User.class, userId);

user1 == user2; // true
```

이게 어떻게 가능한 것일까, 고민을 해봤다.  
객체간의 비교에서 `true`가 나왔다는 것은, 같은 객체를 참조하고 있음을 뜻한다.  
JPA 내부에서 데이터베이스로부터 불러와 매핑한 객체를 어디 한 공간에서 불러오고,  
후에 같은 키를 불러온다면은 같은 객체를 주는 방식일지도 모른다.

그렇다면, SELECT SQL 구문을 여러 번 반복하지 않아도 된다.  
그럼 어느 정도까지 메모리에 데이터베이스와 매핑된 객체를 저장할 수 있고 언제 해제가 되는 것인지 궁금하다.  
일종의 **쓰레드 풀(Thread Pool)**과 비슷하게 객체를 관리할 수도 있을 것 같다.

## ORM을 둘러싼 궁금증

1. ORM 프레임워크는 객체와 관계형 데이터베이스 양쪽을 모두 이해해야 한다. 객체지향 지식 뿐 아니라 SQL과 데이터베이스 지식도 모두 알아야한다.
2. JPA의 동작 원리를 모르고 사용한다면 N+1 같은 이슈로 성능 저하가 일어날 수 있다.
3. JPA는 통계 쿼리 같은 복잡한 SQL 보다 실시간 처리용 쿼리에 더 최적화 되어있다. SQL을 직접 작성하는 것이 더 쉬울 때도 있다.
4. 마이바티스나 스프링 JdbcTemplate을 SQL 매퍼라고 한다. 객체와 SQL을 매핑하는 역할을 한다. 그러나 여전히 SQL에 의존적이다. JPA는 SQL에 의존적인 개발을 피할 수 있다.

## 참고 도서

자바 ORM 표준 JPA 프로그래밍